<!DOCTYPE html>
<html ng-app="jassa.ui.edit.demo.widgets">

  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>RDF Edit Demo</title>

    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <!-- build:css(.tmp) styles/main.css -->

    <!-- bower:css -->
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" />
    <link rel="stylesheet" href="bower_components/ng-grid/ng-grid.css" />
    <link rel="stylesheet" href="bower_components/jassa-ui-angular/jassa-ui-angular.css" />
    <link rel="stylesheet" href="bower_components/components-font-awesome/css/font-awesome.css" />
    <!-- endbower -->

    <link rel="stylesheet" href="../../../target/release/repo/jassa-ui-angular.css" />
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="bower_components/jquery-ui/themes/smoothness/jquery-ui.css" />

    <!-- endbuild -->

    <!-- build:js scripts/scripts.js -->

    <script src="bower_components/jscache/cache.js"></script>

    <!-- bower:js -->
    <script src="bower_components/jquery/jquery.js"></script>
    <script src="bower_components/underscore/underscore.js"></script>
    <script src="bower_components/jassa/jassa.js"></script>
    <script src="bower_components/angular/angular.js"></script>
    <script src="bower_components/bootstrap/dist/js/bootstrap.js"></script>
    <script src="bower_components/ng-grid/build/ng-grid.js"></script>
    <script src="bower_components/angular-sanitize/angular-sanitize.js"></script>
    <script src="bower_components/jquery-ui/ui/jquery-ui.js"></script>
    <script src="bower_components/angular-ui-sortable/sortable.js"></script>
    <script src="bower_components/angular-ui-utils/ui-utils.js"></script>
    <script src="bower_components/jassa-ui-angular/jassa-ui-angular-tpls.js"></script>
    <!-- endbower -->

    <script src="js/directives/jassa-edit-datetime.js"></script>
    <script src="js/directives/jassa-edit-map.js"></script>
    <script src="js/directives/jassa-edit-meta.js"></script>
    <script src="js/directives/jassa-edit-plain.js"></script>
    <script src="js/directives/jassa-edit-sparql-update.js"></script>
    <script src="js/directives/jassa-edit-text.js"></script>
    <script src="js/directives/jassa-edit-typed.js"></script>
    <script src="js/directives/jassa-edit-uri.js"></script>

    <script src="scripts/lib/angular-ui/0.10.0/ui-bootstrap-tpls-0.10.0.js"></script>
    <script src="bower_components/underscore.string/lib/underscore.string.js"></script>

    <script src="bower_components/openlayers/lib/OpenLayers.js"></script>
    <script src="bower_components/jqueryui-timepicker-addon/src/jquery-ui-timepicker-addon.js"></script>

    <!-- endbuild -->


    <script type="text/ng-template" id="template/property-edit-list/property-edit-list.html">
    <div>
        <ul style="list-style-type: none;">
            <li ng-repeat="config in configs">
                <div class="alert alert-warning" role="alert" style="width: 600px;">
                    <span bind-html-unsafe="config.label"></span>
                    <span bind-html-unsafe="config.propertyUri"></span>
                    <div dynamic="config.template"></div>
                </div>
            </li>
        </ul>
        <button type="button" class="btn btn-primary" ng-click="addPropertyConfig()">Add Property</button>
    </div>
    </script>

    <script type="text/ng-template" id="foobar.html">
        <span>Yaaaaay</span>
    </script>

    <script type="text/ng-template" id="template/rdf-switcher.html">
      <span class="input-group-addon"><i class="icon fa fa-globe"></i></span><div class="input-group-btn">
        <!--button type="button" class="btn btn-default no-border-radius" tabindex="-1">Plain</button-->
        <button type="button" class="btn btn-default dropdown-toggle no-border-radius" data-toggle="dropdown" tabindex="-1">
          <span>Plain</span>
          <span class="caret"></span>
          <span class="sr-only">Toggle Dropdown</span>
        </button>
        <ul class="dropdown-menu" role="menu">
          <li><a href="#">URI</a></li>
          <li><a href="#">Typed</a></li>
          <li><a href="#">Plain</a></li>
        </ul>
      </div>
      <div class="input-group-btn">
        <!--button type="button" class="btn btn-default no-border-radius" tabindex="-1">{{datatype.length === 0 ? "No Datatype" : datatype}}</button-->
        <button type="button" class="btn btn-default dropdown-toggle no-border-radius" data-toggle="dropdown" tabindex="-1">
          <span class="ng-binding">http://www.w3.org/2001/XMLSchema#int</span>
          <span class="caret"></span>
          <span class="sr-only">Toggle Dropdown</span>
        </button>
        <ul class="dropdown-menu dropdown-menu-left" role="menu">
        </ul>
      </div>
      <div class="input-group-btn">
        <!--button type="button" class="btn btn-default no-border-radius" tabindex="-1">{{language.length === 0 ? "No Language" : language}}</button-->
        <button type="button" class="btn btn-default dropdown-toggle no-border-radius" data-toggle="dropdown" tabindex="-1">
          <span class="ng-binding">en</span>
          <span class="caret"></span>
          <span class="sr-only">Toggle Dropdown</span>
        </button>
        <ul class="dropdown-menu dropdown-menu-left" role="menu">
        </ul>
      </div>
    </script>

    <script type="text/javascript">
    _.mixin(_.str.exports());

    var rdf = jassa.rdf;
    var sparql = jassa.sparql;
    var service = jassa.service;
    var sponate = jassa.sponate;
    var facete = jassa.facete;
    var util = jassa.util;

    var geo = jassa.geo;

    var vocab = jassa.vocab;


    var ObjectRef = Class.create({
      initialize: function(subject, predicate, objectIndex) {
        this.subject = subject;
        this.predicate = predicate;
        this.objectIndex = objectIndex;
      },

      getSubject: function() {
        return this.subject;
      },

      getPredicate: function() {
        return this.predicate;
      },

      getObjectIndex: function() {
        return this.objectIndex;
      },

      toString: function() {
        return this.subject + ' ' + this.predicate + ' ' + this.objectIndex;
      }
    });


    //this.map = new util.HashMap();


    /*
     var NodeState = Class.create({
     initialize: function() {
     this.termType = null;
     this.lexicalForm = null;
     this.datatype = null;
     this.lang = null;
     },

     getLexicalForm: function() {
     return this.lexicalForm;
     },

     getLang: function() {
     return this.lang;
     },

     setLexicalForm: function(lexicalForm) {
     this.lexicalForm = lexicalForm;
     },

     setLang: function(lang) {
     this.lang = lang;
     }
     });
     */

    var NodeStateUtils = {
      createNode: function(nodeState) {
        console.log('NODESATEUTILS', nodeState, nodeState.hasOwnProperty('lang'));


        /*for (var key in nodeState) {
          if(val[key].length === 0) { delete val[key]; }
        }*/

        // TODO Implement properly
        if(nodeState.lexicalForm == null) {
          return null;
        }

        if(nodeState.hasOwnProperty('datatype')) {
          console.log('hasownprop dtype');
          //if (nodeState.datatype.length > 0) {
            var result = rdf.NodeFactory.createTypedLiteralFromValue(nodeState.lexicalForm, nodeState.datatype);
            return result;
          //}
        }

        if(nodeState.hasOwnProperty('lang')) {
          console.log('hasownprop lang');
          var result = rdf.NodeFactory.createPlainLiteral(nodeState.lexicalForm, nodeState.lang);
          return result;
        }

        var result = rdf.NodeFactory.createPlainLiteral(nodeState.lexicalForm, nodeState.lang);

        return result;
      },

      createNodeLanguage: function(nodeState) {

        // TODO Implement properly
        if(nodeState.lexicalForm == null) {
          return null;
        }

        if(nodeState.hasOwnProperty('lang')) {
          var result = rdf.NodeFactory.createPlainLiteral(nodeState.lexicalForm, nodeState.lang);
          return result;
        }

        var result = rdf.NodeFactory.createPlainLiteral(nodeState.lexicalForm, nodeState.lang);

        return result;
      },

      createNodeDatatype: function(nodeState) {

        // TODO Implement properly
        if(nodeState.lexicalForm == null) {
          return null;
        }

        if(nodeState.hasOwnProperty('datatype')) {
          var result = rdf.NodeFactory.createTypedLiteralFromValue(nodeState.lexicalForm, nodeState.datatype);
          return result;
        }

        var result = rdf.NodeFactory.createPlainLiteral(nodeState.lexicalForm, nodeState.lang);

        return result;
      },
    };


    var TripleBuilder = Class.create({
      initialize: function() {
        //this.map = new util.HashMap();
        this.map = {};
      },
      getSafe: function(objectRef) {
        var key = '' + objectRef;
        var result = this.map[key];

        if(result == null) {
          result = {};
          this.map[key] = result;
        }

        return result;
      },
      remove: function(objectRef) {
        var key = '' + objectRef;
        delete this.map[key];
      }
    });


    var GraphInserter = Class.create({
      initialize: function(graph) {
        this.graph = graph;
        this.tripleBuilder = new TripleBuilder();
      },

      get: function(objectRef) {
        // TODO Maybe we need to check if the reference has been overridden in the triple builder
        var result = ObjectRefUtils.getTriple(this.graph, objectRef);
        return result;
      },

      set: function(objectRef, data) {

        var val = this.tripleBuilder.getSafe(objectRef);

        _(val).extend(data);

        var node = NodeStateUtils.createNode(val);
        if(data.hasOwnProperty('lang')) {
          var node = NodeStateUtils.createNodeLanguage(val);
        }

        if(data.hasOwnProperty('datatype')) {
          var node = NodeStateUtils.createNodeDatatype(val);
        }

        //var node = NodeStateUtils.createNode(val);
        if(node != null) {
          var t = ObjectRefUtils.getTriple(this.graph, objectRef);

          if(t != null) {
            this.graph.remove(t);
          }

          var nt = new rdf.Triple(objectRef.getSubject(), objectRef.getPredicate(), node);
          console.log('nt', nt, data, val, node, t);
          this.graph.add(nt);
        }
      },

      remove: function(objectRef, rdfTermTag) {

      }
    });

    var GraphInserterUtils = {
      getObject: function(graphInserter, objectRef) {
        var t = graphInserter.get(objectRef);
        var result = t == null ? null : t.getObject();
        return result;
      }
    };

    var ns = {};


    ns.NodeMapper = Class.create({
      toNode: function(obj) {
        console.log('Implement me');
      },
      toObject: function(node) {
        console.log('Implement me');
      }
    });


    ns.NodeMapperPlainLiteral = Class.create(ns.NodeMapper, {
      /**
       * @param fnLang function returning a language tag
       */
      initialize: function(lang) {
        this.lang = lang;
      },

      // obj is expected to be a string
      toNode: function(obj) {
        //var lang = this.fnLang();
        var result = rdf.NodeFactory.createPlainLiteral(obj, this.lang);
        return result;
      },

      toObject: function(node) {
        var result = node.getLiteralValue();
        return result;
      }
    });



    ns.ValueStore = Class.create({
      getData: function() {
        console.log('Implement me');
      },
      setData: function(data) {
        console.log('Implement me');
      }
    });

    ns.ValueStoreLex = Class.create({
      initialize: function(graphInserter, objectRef) {
        this.graphInserter = graphInserter;
        this.objectRef = objectRef;
      },

      getData: function() {
        var o = GraphInserterUtils.getObject(this.graphInserter, this.objectRef);
        var result = o == null ? null : o.getLiteralLexicalForm();
        return result;
      },

      setData: function(data) {
        this.graphInserter.set(this.objectRef, {lexicalForm: data});
      },

      getGraphInserter: function() {
        return this.graphInserter;
      },

      getObjectRef: function() {
        return this.objectRef;
      }
    });

    ns.ValueStoreLang = Class.create({
      initialize: function(graphInserter, objectRef) {
        this.graphInserter = graphInserter;
        this.objectRef = objectRef;
      },

      getData: function() {
        var o = GraphInserterUtils.getObject(this.graphInserter, this.objectRef);
        var result = o == null ? null : o.getLiteralLanguage();
        return result;
      },

      setData: function(data) {
        console.log('lang data', data, this.objectRef);
        this.graphInserter.set(this.objectRef, {lang: data});
      },

      getGraphInserter: function() {
        return this.graphInserter;
      },

      getObjectRef: function() {
        return this.objectRef;
      }
    });

    ns.ValueStoreDatatype = Class.create({
      initialize: function(graphInserter, objectRef) {
        this.graphInserter = graphInserter;
        this.objectRef = objectRef;
      },

      getData: function() {
        // if no datatype is defined, return object with getUri function
        var noDatatype = {
          getUri: function () {
            return '';
          }
        };

        var o = GraphInserterUtils.getObject(this.graphInserter, this.objectRef);
        var result = o == null || o.literalLabel.dtype == undefined ? noDatatype : o.getLiteralDatatype();
        return result;
      },

      setData: function(data) {
        this.graphInserter.set(this.objectRef, {datatype: data});
      },

      getGraphInserter: function() {
        return this.graphInserter;
      },

      getObjectRef: function() {
        return this.objectRef;
      }
    });

    var foo = ns;
    var ns = jassa.rdf;
    ns.GraphImpl = Class.create({
      initialize: function() {
        this.triples = new util.HashSet();
      },

      add: function(triple) {
        this.triples.add(triple);
      },

      remove: function(triple) {
        this.triples.remove(triple);
      },

      contains: function(triple) {
        return this.triples.contains(triple);
      },

      toArray: function() {
        return this.triples.entries();
      },

      toString: function() {
        return '' + this.triples;
      }
    });

    var ObjectRefUtils = {
      getObject: function(graph, objectRef) {
        var candidateTriple = this.getTriple(graph, objectRef);

        var result = candidateTriple ? candidateTriple.getObject() : null;
        return result;
      },

      getTriple: function(graph, objectRef) {
        var ts = graph.toArray();
        var i = 0;

        var result = _(ts).find(function(t) {
          var c = objectRef.getSubject().equals(t.getSubject()) &&
                  objectRef.getPredicate().equals(t.getPredicate());

          if(c && objectRef.getObjectIndex() === i) {
            return true;
          }

          if(c) {
            ++i;
          }
        });

        return result;
      }
    };

    var app = angular.module('jassa.ui.edit.demo.widgets', [
      'jassa.ui.edit.demo.widgets.sparqlupdate',
      'jassa.ui.edit.demo.widgets.meta',
      'jassa.ui.edit.demo.widgets.text',
      'jassa.ui.edit.demo.widgets.datetime',
      'ui.bootstrap',
      'ui.jassa']);

    app.directive('propertyEditList', function() {
       return {
           restrict: 'EA',
           /*
           scope: {
               configs: '='
           },
           */
           templateUrl: 'template/property-edit-list/property-edit-list.html'
       };
    });


    app.directive('dynamic', ['$compile', function($compile) {
        return {
            restrict: 'A',
            replace: true,
            link: function(scope, ele, attrs) {
                scope.$watch(attrs.dynamic, function(html) {
                    ele.html(html);
                    $compile(ele.contents())(scope);
                });
            }
        };
    }]);

    app.directive('rdfTermSwitcher', function() {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/rdf-switcher.html',
        link: function(scope, element, attrs) {

        }
      }
    });

    app.directive('rdfTermWidgetIcon', function() {
      return {
        restrict: 'EA',
        replace: true,
        template: '<span class="input-group-addon"><i class="icon fa {{icon}}"></i></span>',
        scope: {
          'valueStore': '='
        },
        link: function(scope, element, attrs) {
          scope.icon = 'fa-globe';
        }
      }
    });

    app.directive('rdfTermWidget', function() {
      return {
        restrict: 'EA',
        replace: true,
        template: '<div><rdf-term-switcher></rdf-term-switcher>\
        <input type="text" class="form-control margin-left-1" ng-model="plainValue">\
          </div>',
        link: function(scope, element, attrs) {

        }
      }
    });

    app.directive('jassaEditMap', function() {

      var mapId = 1;

        return {
          restrict: 'E',
          replace: true,
          //templateUrl: 'template/constraint-list/constraint-list.html',
          templateUrl: 'template/jassa-edit-map.html',
          transclude: false,
          //require: 'constraintList',
          require: 'ngModel',
          scope: {
            'config': '=',
            'geometry': '=',
            'valueStore': '='
          },
          //controller: 'JassaEditMapCtrl',
          link: function(scope, element, attrs, ngModel) {

            mapId = mapId++;

            scope.mapId = mapId;

            var map, drawControls, polygonLayer, panel, wkt, vectors;
            //console.log('geometry', scope.geometry);
            //console.log('mapConfig', scope.config);
            //console.log('valueStoreMap', scope.valueStore);
            scope.wkt = scope.config.data;
            scope.chooseGeometry = scope.geometry;

            scope.$watch(function() {
              return scope.wkt;
            }, function(newValue, oldValue) {
              console.log('old value of input', oldValue);
              // clear layer
              vectors.destroyFeatures();
              // set config data with changed input value ...
              scope.config.data = scope.wkt;
              // ... then call parseWKT to redraw the feature
              parseWKT();
            });

            scope.$watch(function() {
              return scope.config.data;
            }, function(newValue) {
              console.log('map data changed: ', newValue);
              scope.valueStore.setData(newValue);
            });

            scope.$watch(function() {
              return scope.valueStore.getData();
            }, function(newValue) {
              console.log('data reset for map value: ', newValue);
              scope.wkt = scope.config.data;
            });

            scope.$watch(function() {
              return scope.chooseGeometry;
            }, function(newValue) {
              console.log('radio', scope.chooseGeometry);
              scope.geometry = newValue;
              toggleControl();
            });




            function init() {

              var mapDomId = 'openlayers-map';

              map = new OpenLayers.Map(mapDomId);

              var wmsLayer = new OpenLayers.Layer.WMS("OpenLayers WMS",
                "http://vmap0.tiles.osgeo.org/wms/vmap0?", {layers: 'basic'});

              panel = new OpenLayers.Control.Panel({'displayClass': 'olControlEditingToolbar'});

              var snapVertex = {methods: ['vertex', 'edge'], layers: [vectors]};



              // allow testing of specific renderers via "?renderer=Canvas", etc
              var renderer = OpenLayers.Util.getParameters(window.location.href).renderer;
              renderer = (renderer) ? [renderer] : OpenLayers.Layer.Vector.prototype.renderers;

              vectors = new OpenLayers.Layer.Vector("Vector Layer", {
                renderers: renderer
              });

              map.addLayers([wmsLayer, vectors]);
              map.addControl(new OpenLayers.Control.LayerSwitcher());
              map.addControl(new OpenLayers.Control.MousePosition());

              vectors.events.on({
                sketchcomplete: GeometryWasDrawn
              });

              wkt = new OpenLayers.Format.WKT();

              drawControls = {
                point: new OpenLayers.Control.DrawFeature(vectors,
                  OpenLayers.Handler.Point, {
                    displayClass: 'olControlDrawFeaturePoint',
                    handlerOptions: snapVertex}),
                line: new OpenLayers.Control.DrawFeature(vectors,
                  OpenLayers.Handler.Path, {
                    displayClass: 'olControlDrawFeaturePath',
                    handlerOptions: snapVertex}),
                polygon: new OpenLayers.Control.DrawFeature(vectors,
                  OpenLayers.Handler.Polygon, {
                    displayClass: 'olControlDrawFeaturePolygon',
                    handlerOptions: snapVertex}),
                box: new OpenLayers.Control.DrawFeature(vectors,
                  OpenLayers.Handler.RegularPolygon, {
                    displayClass: 'olControlDrawFeatureBox',
                    handlerOptions: _.extend({
                      sides: 4,
                      irregular: true
                    }, snapVertex)
                  }),
                modify: new OpenLayers.Control.ModifyFeature(vectors, {
                  snappingOptions: snapVertex,
                  onModificationStart: onModificationStart,
                  onModification: onModification,
                  onModificationEnd: onModificationEnd
                })
              };

              panel.addControls(drawControls['modify']);
              map.addControl(panel);
              panel.activateControl(drawControls.modify);

              for (var key in drawControls) {
                map.addControl(drawControls[key]);
              }

              map.setCenter(new OpenLayers.LonLat(0, 0), 4);
            }

            function GeometryWasDrawn(drawnGeometry) {
              /*var ft = polygonLayer.features;
               for(var i=0; i< ft.length; i++){
               console.log(polygonLayer.features[i].geometry.getBounds());
               displayWKT(polygonLayer.features[i]);
               };*/
              var wktValue = generateWKT(drawnGeometry.feature);
              scope.config.data = wktValue;
              scope.$apply();
            }

            function generateWKT(feature) {
              var str = wkt.write(feature);
              str = str.replace(/,/g, ', ');
              return str;
            }

            function parseWKT() {
              //var element = document.getElementById('wkt');
              var features = wkt.read(scope.config.data);
              var bounds;
              if(features) {
                if(features.constructor != Array) {
                  features = [features];
                }
                for(var i=0; i<features.length; ++i) {
                  if (!bounds) {
                    bounds = features[i].geometry.getBounds();
                  } else {
                    bounds.extend(features[i].geometry.getBounds());
                  }

                }
                vectors.addFeatures(features);
                map.zoomToExtent(bounds);
                var plural = (features.length > 1) ? 's' : '';
                console.log('Added WKT-String. Feature' + plural + ' added');
              } else {
                console.log('Bad WKT');
              }
            }

            function toggleControl() {
              console.log('toggleControl', scope.geometry);
              var control = drawControls[scope.geometry];
              for(key in drawControls) {
                var control = drawControls[key];
                if(scope.geometry == key && scope.chooseGeometry) {
                  control.activate();
                } else {
                  control.deactivate();
                }
              }
            }

            function onModificationStart(feature) {
              console.log(feature.id + " is ready to be modified");
              drawControls[scope.geometry].deactivate();

            }

            function onModification(feature) {
              console.log(feature.id + " has been modified");
              var wktValue = generateWKT(feature);
              scope.config.data = wktValue;
              scope.$apply();
            }

            function onModificationEnd(feature) {
              console.log(feature.id + " is finished to be modified");
              drawControls[scope.geometry].activate();
            }


            // init openlayers
            init();

            // set geometry
            var control = drawControls[scope.geometry];
            control.activate();
          }
        };
      });




    app.controller('AppCtrl', ['$scope', function($scope) {
      var graph = new rdf.GraphImpl();

      var s = rdf.NodeFactory.createUri('http://s');
      var p1 = rdf.NodeFactory.createUri('http://p');
      var p2 = rdf.NodeFactory.createUri('http://www.opengis.net/ont/geosparql#asWKT');
      var p3 = rdf.NodeFactory.createUri('http://p3plaintest');
      var p4 = rdf.NodeFactory.createUri('http://p4typedtest');
      var p5 = rdf.NodeFactory.createUri('http://p5datetimetest');
      var p6 = rdf.NodeFactory.createUri('http://p5timetest');
      var o1 = rdf.NodeFactory.createUri('http://o1');
      var o2 = rdf.NodeFactory.createUri('http://o2');
      var o3 = rdf.NodeFactory.createTypedLiteralFromValue("POLYGON((-15.8203125 2.4609375, -15.8203125 -10.546875, 6.85546875 -11.25, 8.26171875 -3.33984375, -15.8203125 2.4609375))", "http://www.opengis.net/ont/geosparql#wktLiteral");
      var o4 = rdf.NodeFactory.createPlainLiteral("Plain Literal with Language Tag", "en");
      var o5 = rdf.NodeFactory.createTypedLiteralFromValue("123", "http://www.w3.org/2001/XMLSchema#int");
      var o6 = rdf.NodeFactory.createTypedLiteralFromValue("2002-09-24", "http://www.w3.org/2001/XMLSchema#date");
      var o7 = rdf.NodeFactory.createTypedLiteralFromValue("21:55:16Z", "http://www.w3.org/2001/XMLSchema#time");

      var t1 = new rdf.Triple(s, p1, o1);
      var t2 = new rdf.Triple(s, p1, o2);
      var t3 = new rdf.Triple(s, p2, o3);
      var t4 = new rdf.Triple(s, p3, o4);
      var t5 = new rdf.Triple(s, p4, o5);
      var t6 = new rdf.Triple(s, p5, o6);
      var t7 = new rdf.Triple(s, p6, o7);

      graph.add(t1);
      graph.add(t2);
      graph.add(t3);
      graph.add(t4);
      graph.add(t5);
      graph.add(t6);
      graph.add(t7);

      console.log('graph', graph);
      //console.log(graph.contains(t1));

      var ref = new ObjectRef(s, p1, 0);
      var ref2 = new ObjectRef(s, p1, 1);
      var ref3 = new ObjectRef(s, p2, 0);
      var ref4 = new ObjectRef(s, p3, 0);
      var ref5 = new ObjectRef(s, p4, 0);
      var ref6 = new ObjectRef(s, p5, 0);
      var ref7 = new ObjectRef(s, p6, 0);

      console.log('Object for ref ' + ref + ': ' + ObjectRefUtils.getObject(graph, ref));
      console.log('Object for ref ' + ref2 + ': ' + ObjectRefUtils.getObject(graph, ref2));
      console.log('Object for ref3 ' + ref3 + ': ' + ObjectRefUtils.getObject(graph, ref3));
      console.log('Object for ref4 ' + ref4 + ': ' + ObjectRefUtils.getObject(graph, ref4));
      console.log('Object for ref5 ' + ref5 + ': ' + ObjectRefUtils.getObject(graph, ref5));
      console.log('Object for ref6 ' + ref6 + ': ' + ObjectRefUtils.getObject(graph, ref6));
      console.log('Object for ref7 ' + ref7 + ': ' + ObjectRefUtils.getObject(graph, ref7));

      $scope.lang = 'en';

      var graphInserter = new GraphInserter(graph);

      $scope.myValueStore = new foo.ValueStoreLex(graphInserter, ref);
      $scope.myValueStoreLang = new foo.ValueStoreLang(graphInserter, ref);

      $scope.myValueStore2 = new foo.ValueStoreLex(graphInserter, ref2);

      $scope.myValueStoreGeneralConfig = {
        lex: new foo.ValueStoreLex(graphInserter, ref4),
        lang: new foo.ValueStoreLang(graphInserter, ref4),
        dtype: new foo.ValueStoreDatatype(graphInserter, ref4)
      };

      $scope.myValueStoreGeneral2Config = {
        lex: new foo.ValueStoreLex(graphInserter, ref5),
        lang: new foo.ValueStoreLang(graphInserter, ref5),
        dtype: new foo.ValueStoreDatatype(graphInserter, ref5)
      };

      $scope.myValueStorePlainConfig = {
        lex: new foo.ValueStoreLex(graphInserter, ref4),
        lang: new foo.ValueStoreLang(graphInserter, ref4),
        icon: 'fa-globe'
      };

      $scope.myValueStoreTypedConfig = {
        lex: new foo.ValueStoreLex(graphInserter, ref5),
        dtype: new foo.ValueStoreDatatype(graphInserter, ref5)
      };

      $scope.myValueStoreTyped = new foo.ValueStoreLex(graphInserter, ref5);

      $scope.myValueStoreDateTimeConfig = {
        lex: new foo.ValueStoreLex(graphInserter, ref6),
        dtype: new foo.ValueStoreDatatype(graphInserter, ref6)
      };

      $scope.myValueStoreDateTimeConfig2 = {
        lex: new foo.ValueStoreLex(graphInserter, ref7),
        dtype: new foo.ValueStoreDatatype(graphInserter, ref7)
      };

      $scope.myModel = "hello world";

      // Map Widget Configuration
      $scope.myMapsModel = "Foo";
      // OpenLayers Map
      $scope.mapConfig = {
        'zoom' : 8,
        'data' : 'POLYGON((-15.8203125 2.4609375, -15.8203125 -10.546875, 6.85546875 -11.25, 8.26171875 -3.33984375, -15.8203125 2.4609375))'
      };

      $scope.geometryConfig = "polygon";

      $scope.myValueStoreMap = new foo.ValueStoreLex(graphInserter, ref3);
      $scope.myValueStoreMapDatatype = new foo.ValueStoreDatatype(graphInserter, ref3);


      $scope.myValueStoreMeta = new foo.ValueStoreLex(graphInserter, ref);
      // generate graph
      $scope.datatype = "http://www.opengis.net/ont/geosparql#wktLiteral";
      $scope.graph = graph;
      $scope.$watch('"" + graph', function() {
        console.log('Graph: ' + graph);
      });

      $scope.graphImpl = graph;
      $scope.sparqlEndpoint = 'http://localhost/sparql';

      $scope.configs = [{
          label: '<strong>foo</strong>',
          propertyUri: 'rdfs:label',
          template: '<jassa-edit-meta rdf-term-type="typed" value-store="myValueStoreGeneral2Config"></jassa-edit-meta>'
      }, {
          label: '<strong>bar</strong>',
          propertyUri: 'rdf:type',
          template: '<span>yay</span>'
          //template: 'foobar.html' //'<jassa-edit-meta typed value-store="myValueStoreTypedConfig"></jassa-edit-meta>'
      }];

      $scope.addPropertyConfig = function() {
          $scope.configs.push({
              label: '<strong>foo</strong>',
              propertyUri: 'rdfs:label',
              template: '<jassa-edit-meta rdf-term-type="plain" value-store="myValueStoreGeneralConfig"></jassa-edit-meta>'
          });
      };


    }]);

    </script>

  </head>

<!--

    Terminologie:

    rdfTermSwitcher: Nur RdfTermType, Languague und DatatypeSwitcher
    rdfTermWidget: rdfTermSwitcher + InputElement + InputEditorSupport (Popup beim Input Element)


    defaultMetaWidget:
    <div class="input-group">
        <rdf-term-switcher icon="?"> value-store="rdfTerm"</rdf-term-switcher> // .termType .lang .dataType
        <input ng-model="rdfTermX.lex" rdf-value="valueStore"></input>
    </div>


    groupMetaWidget:
    <div>
        <meta-widget valueStore="valueStore" inputEditorSupport="someFn(inputElement, valueStore)"></meta-widget>
        <div widgetFactory="someFunctionReturningAWidgetBasedOnTheRdfTerm(valueStore)">

        <jassa-edit-map></jassa-edit-map>
    </div>


    -->
<!--
    <rdf-term-switcher icon="?"> value-store="valueStore2"</rdf-term-switcher>
    <jassa-edit-map ng-if="valueStore1.lex.getDatatype() == 'foo' && valueStore2.lex.getDataype() === 'bar'> value-store="valueStore2"></jassa-edit-map>
 -->


  <body ng-controller="AppCtrl">

    <h1>PropertyEditList</h1>
    <property-edit-list configs="configs"></property-edit-list>
<!--
    <h1>Templating</h1>
    <div class="alert alert-warning" role="alert" style="width: 500px;">
      <jassa-edit-meta typed value-store="myValueStoreTypedConfig"></jassa-edit-meta>
      <textarea style="width: 100%" rows="7"></textarea>
    </div>
    <h1>RDFTermSwitcher</h1>
    <div class="input-group">
      <rdf-term-widget-icon type="plain" value-store="myValueStorePlainConfig"></rdf-term-widget>
      <rdf-term-switcher value-store="myValueStorePlainConfig"></rdf-term-switcher>
      <input class="form-control margin-left-1" ng-model="test" value-store="myValueStorePlainConfig" />
    </div>
    <h1>SPARQL Update</h1>
    <jassa-edit-sparql-update graph="graphImpl" endpoint="sparqlEndpoint"></jassa-edit-sparql-update>
    <h1>Simple edit with input</h1>
    <jassa-edit-text ng-model="myModel" value-store="myValueStore"></jassa-edit-text>
    <jassa-edit-text ng-model="lang" value-store="myValueStoreLang"></jassa-edit-text>

-->
    <h1>Meta | Plain | Typed | URI Widget</h1>
<!--
    <jassa-edit-plain value-store="myValueStorePlainConfig"></jassa-edit-plain>
    <jassa-edit-typed value-store="myValueStoreTypedConfig"></jassa-edit-typed>
    <jassa-edit-uri ng-model="myMetaModel" value-store="myValueStoreMeta"></jassa-edit-uri>
    <!--jassa-edit-meta typed value-store="myValueStoreTypedConfig"></jassa-edit-meta-->
    <!--jassa-edit-meta plain value-store="myValueStorePlainConfig"></jassa-edit-meta-->
    <jassa-edit-meta rdf-term-type="plain" value-store="myValueStoreGeneralConfig"></jassa-edit-meta>
    <jassa-edit-meta rdf-term-type="plain" value-store="myValueStoreGeneralConfig"></jassa-edit-meta>
    <jassa-edit-meta rdf-term-type="typed" value-store="myValueStoreGeneral2Config"></jassa-edit-meta>
    <jassa-edit-meta rdf-term-type="typed" value-store="myValueStoreGeneral2Config"></jassa-edit-meta>
<!--
    <h1>DateTime Widget</h1>
    <jassa-edit-datetime value-store="myValueStoreDateTimeConfig"></jassa-edit-datetime>
    <jassa-edit-datetime value-store="myValueStoreDateTimeConfig"></jassa-edit-datetime>
    <jassa-edit-datetime value-store="myValueStoreDateTimeConfig2"></jassa-edit-datetime>
    <h1>Map widget</h1>
    <jassa-edit-text ng-model="datatype" value-store="myValueStoreMapDatatype"></jassa-edit-text>
    <jassa-edit-map ng-model="myMapsModel" config="mapConfig" geometry="geometryConfig" value-store="myValueStoreMap"></jassa-edit-map>

    <!--jassa-edit-map ng-model="myMapsModel" config="mapConfig" geometry="geometryConfig" value-store="myValueStoreMap"></jassa-edit-map-->
  </body>

</html>