<!DOCTYPE html>
<html ng-app="jassa.ui.edit.demo.widgets">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>RDF Edit Demo</title>

    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

    <!-- build:css(.tmp) styles/main.css -->

    <!-- bower:css -->
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" />
    <link rel="stylesheet" href="bower_components/ng-grid/ng-grid.css" />
    <link rel="stylesheet" href="bower_components/jassa-ui-angular/jassa-ui-angular.css" />
    <!-- endbower -->

    <link rel="stylesheet" href="css/style.css" />

    <!-- endbuild -->

    <!-- bower:js -->
    <script src="bower_components/jquery/dist/jquery.js"></script>
    <script src="bower_components/jassa/jassa.js"></script>
    <script src="bower_components/angular/angular.js"></script>
    <script src="bower_components/bootstrap/dist/js/bootstrap.js"></script>
    <script src="bower_components/angular-ui-bootstrap-bower/ui-bootstrap-tpls.js"></script>
    <script src="bower_components/ng-grid/build/ng-grid.js"></script>
    <script src="bower_components/angular-sanitize/angular-sanitize.js"></script>
    <script src="bower_components/jquery-ui/ui/jquery-ui.js"></script>
    <script src="bower_components/angular-ui-sortable/sortable.js"></script>
    <script src="bower_components/angular-ui-utils/ui-utils.js"></script>
    <script src="bower_components/jassa-ui-angular/jassa-ui-angular-tpls.js"></script>
    <script src="bower_components/bluebird/js/browser/bluebird.js"></script>
    <script src="bower_components/underscore/underscore.js"></script>
    <!-- endbower -->

    <!-- endbuild -->

    <script src="js/rex.js"></script>

    <script type="text/ng-template" id="partials/jassa-ui-angular-edit/form.html">
    <ul ui-sortable>
        <li ng-repeat="subject in formData.subjects">
            {{subject.iri}}
            <ul ui-sortable>
                <li ng-repeat="value in values">{{value}}</li>
                <li><button type="button" class="btn btn-primary" ng-click="addProperty()">Add Property</button></li>
            </ul>
        </li>
        <li><button type="button" class="btn btn-primary" ng-click="addSubject()">Add Resource</button></li>
    </ul>
    </script>

    <script type="text/ng-template" id="partials/jassa-ui-angular-edit/property-list.html">
    <ul ui-sortable>
        <li ng-repeat="value in values">{{value}}</li>
        <li><button type="button" class="btn btn-primary" ng-click="addPropertyConfig()">Add Value</button></li>
    </ul>
    </script>

    <script type="text/ng-template" id="partials/jassa-ui-angular-edit/property.html">
    <li>
        <button type="button" class="btn btn-primary" ng-click="addPropertyConfig()">Add Value</button>
    </li>
    </script>




    <script type="text/javascript">
    //_.mixin(_.str.exports());

    var jassa = new Jassa(Promise, $.ajax);

    var vocab = jassa.vocab;
    var rdf = jassa.rdf;
    var sparql = jassa.sparql;
    var service = jassa.service;
    var sponate = jassa.sponate;
    var facete = jassa.facete;
    var util = jassa.util;

    var geo = jassa.geo;

    var vocab = jassa.vocab;


    var getRawState = function(rexContext) {
        var result = {};

        //if(rexContext) {
            rexContext.resources.forEach(function(resourceScope) {
                var subjectUri = resourceScope.rexResource;

                if(!subjectUri) {
                    return;
                }

                var p = result[subjectUri] = (result[subjectUri] || {});

                resourceScope.properties.forEach(function(propertyScope) {
                    var propertyUri = propertyScope.rexProperty;

                    var o = p[propertyUri] = (p[propertyUri] || []);
                });
            });
        //}

        console.log('rexContext: ', rexContext, result);

        return result;
    };



    var nestedMapsToTriples = function(spos) {
        var result = [];

        _.forEach(spos, function(pos, s) {
            var x = rdf.NodeFactory.createUri(s);

            _.forEach(pos, function(os, p) {
                var y = rdf.NodeFactory.createUri(p);

                os.forEach(function(o) {
                    var z = rdf.NodeFactory.createUri(o); // TODO Make that properly

                    var triple = new rdf.Triple(x, y, z);
                    result.push(triple);
                });
            });
        });

        return result;
    };



    var sparqlService = service.SparqlServiceBuilder
        .http('http://dbpedia.org/sparql', ['http://dbpedia.org'], {type: 'POST'})
        .cache().virtFix().paginate(50000).pageExpand(100).create();

    var store = new sponate.StoreFacade(sparqlService, {
//        'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
//        'llo': 'http://www.linklion.org/ontology#'
    });

    var bestLiteralConfig = new sparql.BestLabelConfig(); //['ja', 'ko', 'en', '']);
    var mappedConcept = sponate.MappedConceptUtils.createMappedConceptBestLabel(bestLiteralConfig);

    store.addMap({
        name: 'spo',
        template: [{
            id: '?s',
            displayLabel: { $ref: { target: mappedConcept, attr: 'displayLabel' }},
            predicates: [{
                id: '?p',
                displayLabel: { $ref: { target: mappedConcept, attr: 'displayLabel', on: '?p' }},
                values: [{
                    id: '?o',
                    displayLabel: { $ref: { target: mappedConcept, attr: 'displayLabel', on: '?o' }},
                }]
            }]
        }],
        from: '?s ?p ?o',
    });

    var ls = store.spo.getListService();

    ls = new service.LookupServiceListServiceSparql(ls);

    ls.lookup([rdf.NodeFactory.createUri('http://dbpedia.org/resource/Leipzig')]).then(function(map) {
       alert(JSON.stringify(map));
    });




    /*
    'jassa.ui.edit.demo.widgets', [
      'jassa.ui.edit.demo.widgets.sparqlupdate',
      'jassa.ui.edit.demo.widgets.meta',
      'jassa.ui.edit.demo.widgets.plain',
      'jassa.ui.edit.demo.widgets.typed',
      'jassa.ui.edit.demo.widgets.uri',
      'jassa.ui.edit.demo.widgets.text',
      'jassa.ui.edit.demo.widgets.datetime',
      'ui.bootstrap',
      'ui.jassa']);
   */


// For simplicity, we maybe should leave out the graph, and assume that this is part of the context instead
//     .directive('rexGraph', function() {
//         return {
//             priority: 10,
//             restrict: 'A',
//             scope: true,
//             controller: ['$scope', function($scope) {
//                 var properties = [];

//                 this.getValue = function() {
//                     return $scope.rexGraph;
//                 };

//                 this.addProperty = function(scope) {
//                     console.log('Added property to resource ', this.getValue(), scope);
//                     properties.push(scope);
//                 };

//             }],
//             link: function(scope, ele, attrs, ctrls) {
//                 scope.rexResource = scope.$parent.$eval(attrs.rexResource);

//                 console.log('<resource>', scope.rexResource);
//             }
//         };
//     })

    angular.module('jassa.ui.edit.demo.widgets', ['ngSanitize', 'ui.bootstrap', 'ui.jassa', 'ui.jassa.rex'])

    .directive('modelGraph', function() {
        return {
            priority: 6,
            restrict: 'A',
            require: ['?^rexResource', '?^rexProperty', '?^rexDatatype', '?^rexLang', '?^rexTypeof'],
            // '?^about', '?^rel', '?^rev', '?^src', '?^href', '?^content'
            link: function(scope, ele, attrs, ctrls) {
                var datatypeCtrl = ctrls[8];
                console.log('States: ', ctrls); //ctrls[5], ctrls[6], ctrls[8]);

                console.log('Got datatype: ' + datatypeCtrl.getDatatype());
            }
        };
    })

    .controller('RdfFormCtrl', ['$scope', function($scope) {
        $scope.addSubject = function() {
            $scope.formData.push({
                url: 'http://foo',
                values: [{
                    type: 'iri',
                    lexicalValue: 'foo',
                    datatype: 'xsd:string',
                    lang: 'en'
                }]
            });
        }
    }])

    .directive('rdfForm', ['$compile', function($compile) {
        return {
            restrict: 'EA',
            replace: true,
            templateUrl: 'partials/jassa-ui-angular-edit/form.html',
            scope: {
                formData: '='
            },
            controller: 'RdfFormCtrl',
            link: function(scope, ele, attrs) {
//                 scope.$watch(attrs.dynamic, function(html) {
//                     ele.html(html);
//                     $compile(ele.contents())(scope);
//                 });
            }
        };
    }])

    .controller('AppCtrl', ['$scope', function($scope) {
        $scope.formData = {
            subjects: [{
                url: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
                values: [{
                    type: 'iri',
                    lexicalValue: 'foo',
                    datatype: 'xsd:string',
                    lang: 'en'
                }]
            }, {
                url: 'http://www.w3.org/2000/01/rdf-schema#label',
                values: [{
                    type: 'iri',
                    lexicalValue: 'foo',
                    datatype: 'xsd:string',
                    lang: 'en'
                }]
            }]
        };


        $scope.editContext = {};

        $scope.getRawState = getRawState;
        $scope.$watch('getRawState(editContext)', function(editContext) {
           //console.log('Changed context: ', editContext);
           console.log('Triples: ', nestedMapsToTriples(editContext));
        }, true);

        $scope.items = ['http://dbpedia.org/resource/Leipzig', 'http://dbpedia.org/resource/London'];

        $scope.propertyUri = 'http://www.w3.org/2000/01/rdf-schema#label';

        var PointUtils = {
            lonlatToWkt: function(lonlat) {
                var result = this.pointToWkt(lonlat.lon, lonlat.lat);
                return result;
            },

            xyToWkt: function(xy) {
                var result = this.pointToWkt(xy.x, xy.y);
                return result;
            },

            pointToWkt: function(x, y) {
                var result = 'POINT (' + x + ' ' + y + ')';
                return result;
            },

            wktPointRegex: /\s*POINT\s*\(([^\s]+)\s*([^)]+)\)\s*/,

            wktToXy: function(wktStr) {
                var match = this.wktPointRegex.exec(wktStr);
                var xStr = match[1];
                var yStr = match[2];

                var result = {
                    x: parseFloat(xStr),
                    y: parseFloat(yStr)
                };

                return result;
            }
        };

        //alert(JSON.stringify(PointUtils.wktToXy('POINT(123 456)')));

        var wgsTripleFnFactory = function(subject, latPredicate, longPredicate, datatypeStr) {
            latPredicate = latPredicate || vocab.wgs84.lat;
            lonPredicate = longPredicate || vocab.wgs84.lon;
            datatypeStr = datatypeStr || vocab.xsd.xstring.getUri();

            var result = function(xy) {
                var x = rdf.NodeFactory.createTypedLiteralFromString('' + xy.x, datatypeStr);
                var y = rdf.NodeFactory.createTypedLiteralFromString('' + xy.y, datatypeStr);

                var r = [
                    new rdf.Triple(subject, latPredicate, x),
                    new rdf.Triple(subject, longPredicate, y)
                ]

                return r;
            };

            return result;
        };

        // Note: referencing values in a json-rdf representation is done with object-refs
        // The question is: how does an objectref referencen the object component of a triple?
                // Option A: By index - drawback is that this is not necessarily stable under sort
                // Option B: By a generated id - we could just alloc one whenever we encounter an object

        // Issue: How to create objects?
                // I think datatype and lang (possibly term type) can be seen as modifiers for a given value
                // So rex-value="expr" could be the main attribute for generating rdf-terms
                // if no rex-type, rex-lang or rex-datatype are present, than a default of xsd:string with no language tag is assumed

                // A general question is, whether arbitrary rdf terms should be allowed in predicate and subject posititons
                // Since in an edit scenario there is not much point in blank-node-resources, i suppose it is safe to omit this features

        // Issue: Are conflicts possible with the rex directives - such as having the same object with distinct values



        wgsTripleFn = wgsTripleFnFactory(rdf.NodeFactory.createUri('http://foobar'));

        //alert(JSON.stringify(wgsTripleFn({x: 1, y: 2})));


        var wktToWgs = {
            write: function(wktStr) {
                // Check if the wgs
            },
            read: function() {

            }
        }

        $scope.wgsModel = function(newVal) {

            //return angular.isDefined(newName) ? (_name = newName) : _name;

            return 'temp';
        };


        var RexContext = jassa.ext.Class.create({
            initialize: function(lookupService) {
                this.lookupService = lookupService;

                // the status of the resources as retrieved from the lookup service
                this.cache = new util.HashMap();

                // values
                // this.overrides = {};

            },

            fetchData: function(subject) {
                if(this.cache.containsKey(subject)) {
                    // TODO Do something
                }

                this.lookupService.lookup([subject]).then(function(map) {
                    this.cache.putMap(map);
                });

            },

            /*
            fetchProperties: function(subjectNode) {
                var r = this.lookupService.lookup([subjectNode]).then(function(map) {
                    var s = map.get(subjectNode);

                });
                return r;
            }
            */
        });



    }]);
    </script>
</head>


<body ng-controller="AppCtrl">

    <input type="text" ng-model="propertyUri">


    <div rex-context="formContext" rex-resource="'someResource'">
        <div ng-repeat="property in formContext.fetchProperties(someResource)" rex-property="property">
            <div ng-repeat=""></div>
        </div>
    </div>

    <div rex-context="editContext">
        <div ng-repeat="item in items" rex-resource="item">
            <div rex-property="propertyUri">
                <span rex-value="'yay'" rex-object>test</span>



                <input ng-model="m" type="text" rex-datatype="'http://www.w3.org/2001/XMLSchema#string'" rex-lang="'en'" rex-object>

                <!-- Note rex-value="m" is not necessary, as rex-object will by default interpret any present ng-model as the lex-value -->

                <button rex-term="'yay'" class="btn btn-primary" ng-click="items = items.splice($index, 1)"><span class="glyphicon glyphicon-remove-circle"></span></button>
            </div>

            <div rex-graph="">
                <input type="text" ng-model="wgsModel" ng-model-options="{ getterSetter: true }" rex-object>
            </div>

        </div>
    </div>


<!--     <rdf-form -->
<!--         formData="formData" -->
<!--     ></rdf-form> -->

</body>

</html>